%% ------- ROZDZIAŁ 2 ------- %%

\chapter{Zastosowanie języka programowania Python w obliczeniach analitycznych}
Python jest językiem programowania wysokiego poziomu, charakteryzujący się przede wszystkim wysoką klarownością i czytelnością kodu.
Jest to język interpretowany, co w odróżnieniu od języków kompilowanych pozwala na bardzo szybkie tworzenie i testowanie kodu.
Wadą tego rozwiązania jest niestety spadek wydajności oraz zwiększone zużycie pamięci i procesora, jednak zastosowania praktyczne Pythona zazwyczaj pozwalają na poniesienie tego typu kosztów.

Python został stworzony w 1989 roku przez Guido van Rossum, a do dzisiaj rozwijany jest jako projekt Open Source i zarządzany przez organizację non-profit Python Software Foundation.
Jego specyficzna struktura oraz cechy takie jak dynamiczne typowanie, automatyczna zarządzanie pamięcią, przenośność, czy duża czytelność i prostota kodu, 
umożliwiają bardzo szybkie wytwarzanie i utrzymywanie aplikacji.\\

Biblioteka standardowa języka Python zawiera wiele użytecznych modułów i gotowych rozwiązań, które wspomagają szybką i efektywną implementację kodu.
Ponadto dostępny jest \textit{Python Package Index} (PyPI) - zbiór paczek zewnętrznych, tworzonych przez niezależnych programistów, dystrybuowanych na licencjach Open Source.
Dzięki takiej mnogości pakietów i modułów język Python może być wykorzystywany w wielu projektach, łącząc różne technologie i dziedziny informatyki.
Jednym z przykładów wykorzystania tego języka jest tworzenie aplikacji internetowych za pomocą frameworku Django.
Łączy on ze sobą różne technologie wykorzystywane przy tworzeniu serwisów internetowych, zapewniając bardzo dobry mechanizm back-endowy oraz wygodne środowisko.\\

Ze względu na wyżej wymienione cechy Python znalazł również zastosowanie w analityce i analizie danych, włączając w to analizę danych statystycznych i giełdowych, a także we wspomaganiu obliczeń matematycznych.


\section{Cechy charakterystyczne języka Python}
Podstawową charakterystyczną cechą języka Python jest fakt, iż nie jest on kompilowany lecz interpretowany, czyli tłumaczony do wykonywalnego kodu maszynowego lub kodu pośredniego.
Dzięki użyciu interpretera w konsoli systemowej można bezpośrednio wykonywać kod Pythona w czasie rzeczywistym.


\begin{lstlisting}
Python 2.7.12 (default, Nov 20 2017, 18:23:56) 
[GCC 5.4.0 20160609] on linux2
Type "help", "copyright", "credits" or "license" for more information. 
>>> from sklearn import datasets
>>> 
>>> iris = datasets.load_iris()
>>> digits = datasets.load_digits()
>>> digits.data
array([[  0.,   0.,   5., ...,   0.,   0.,   0.],
       [  0.,   0.,   0., ...,  10.,   0.,   0.],
       [  0.,   0.,   0., ...,  16.,   9.,   0.],
       ..., 
       [  0.,   0.,   1., ...,   6.,   0.,   0.],
       [  0.,   0.,   2., ...,  12.,   0.,   0.],
       [  0.,   0.,  10., ...,  12.,   1.,   0.]])
>>>
>>>
\end{lstlisting}

Pozwala to na bardzo szybkie testowanie niewielkich fragmentów kodu, użycia bibliotek, a także przeprowadzanie testowych obliczeń.
Jest to również doskonałe narzędzie do sprawdzania i dostosowywania środowiska, w szczególności gdy użyte zostaje symulowane środowisko - program \textit{virtualenv}, 
który instaluje wybraną wersję interpretera we wskazanym katalogu i umożliwia instalowanie bibliotek niezależnie od tych, które zainstalowane są w systemie.\\

Kolejną wartą uwagi cechą języka Python jest jego składnia. W odróżnieniu od języków takich jak na przykład Java czy C++, w Pythonie zastosowano tak zwane dynamiczne typowanie.
Oznacza to, że podczas definiowania zmiennych nie określa się ich typu. Jest to możliwe, ponieważ w języku Python każdy element, na przykład funkcja, klasa czy też struktura danych jest obiektem.
Obiekt ten ma z góry zdefiniowany typ, więc przypisanie jego referencji do konkretnej zmiennej pomaga go w ten sposób określić.
\begin{lstlisting}
  Python 2.7.12 (default, Nov 20 2017, 18:23:56) 
  [GCC 5.4.0 20160609] on linux2
  Type "help", "copyright", "credits" or "license" for more information.
  >>> variable_one = 44
  >>> type(variable_one)
  <type 'int'>
  >>> 
  >>> variable_one = 'text'
  >>> type(variable_one)
  <type 'str'>
  >>> 
\end{lstlisting}

Jedną z najbardziej użytecznych cech Pythona jest zastosowanie elementów programowania funcyjnego. Elementami takimi są przykładowo wyrażenia \textit{lambda}, oraz \textit{list comprehension} i \textit{dict comprehension}.
Wyrażenia \textit{lambda} pozwalają na stworzenie i przypisanie do zmiennej ktrótkiej funkcji, która jest w stanie przyjmować argumenty oraz zwracać wartości.
Znajduje to zastosowanie w przypadkach, które wymagają wielokrotnego wykorzystania danego fragmentu kodu, a użycie ich skraca znacznie ilość wypisanych poleceń.
Pozwala to uniknąć tworzenia wielu krótkich funkcji lub metod poza obecnie wykorzystywaną przestrzenią, co często wpływa pozytywnie przede wszsytkim na czytelność kodu.

Wyrażenia \textit{list comprehension} oraz \textit{dict comprehension} wykorzystywane są do szybkiego tworzenia odpowiednio list oraz słowników.
W swojej konstrukcji zawierają pętlę \textit{For}, która iteruje po wskazanej strukturze, na przykład liście, zwracając w każdym kroku jeden jej element.
Element ten może być sprawdzony warunkiem wbudowanym w strukturę, oraz następnie zmieniony i wbudowany w nową listę lub słownik.

\begin{lstlisting}
  Python 2.7.12 (default, Nov 20 2017, 18:23:56) 
  [GCC 5.4.0 20160609] on linux2
  Type "help", "copyright", "credits" or "license" for more information. 
  >>> test_lambda = lambda x: x+5
  >>> test_lambda(10)
  15
  >>> 
  >>> test_list = [1, 2, 3, 4, 5]
  >>> 
  >>> list_comprehension = [x+5 for x in test_list]
  >>> list_comprehension
  [6, 7, 8, 9, 10]
  >>> 
  >>> dict_comprehension = {x: x+1 for x in test_list}
  >>> dict_comprehension
  {1: 2, 2: 3, 3: 4, 4: 5, 5: 6}
  >>> 
\end{lstlisting}

Naturalnie, natura i składnia języka Python jest o wiele bardziej różnorodna, a przedstawione przykłady odzwierciedlają jedynie namiastkę jego możliwości.
Należałoby wspomnieć tutaj między innymi o posługiwaniu się choćby wbudowanymi strukturami danych, wykorzystaniu programowania orientowanego obiektowo oraz typowych dla niego elementach.
Niemniej jednak, biorąc pod uwagę temat niniejszej pracy, którym jest przedstawienie możliwości biblioteki \textit{Scikit-learn}, wyżej wymienione podstawy uzupełnione późniejszymi wyjaśnieniami powinny wystarczyć aby w pełni zrozumieć naturę problemu.




\section{Python w obliczeniach analitycznych}
Język programowania Python jest bardzo dobrym narzędziem wspomagającym obliczenia analityczne.
Cechy tego języka zapewniają skoncentrowanie się na bezpośrednim podejściu do problemu tworzenia algorytmów i modeli, minimalizując czas projektowania od podstaw skomplikowanych algorytmów pomocnicznych.
Jednak największą zaletą tego języka jest dostępność wielu bibliotek z gotowymi rozwiązaniami, które mogą zostać wykorzystane do sprawnej implementacji modeli analitycznych.
Podstawowymi bibliotekami wspomagającymi przeprowadzanie obliczeń matematycznych są \textit{NumPy} i \textit{SciPy}.\\

Pierwsza z nich dostarcza przede wszystkim obiekty wielowymiarowych list oraz szereg metod i funkcji umożliwiających szybką manipulację, przetwarzanie i stortowanie.
Zawiera także zestaw metod pozwalających na przeprowadzanie podstawowych działań statystycznych i matematycznych\cite{numpy_ug}. Stosowana jest w wielu innych bibliotekach analitycznych, na przykład w pakiecie \textit{Scikit-learn}.\\

Podstawową różnicą pomiędzy obiektami \textit{array} z pakietu \textit{NumPy}, a wbudowanymi listami języka Python jest fakt, iż podczas tworzenia obiektu ustala się stały rozmiar struktury, 
a każde zwiększenie tego rozmiaru powoduje powstanie nowego obiektu i usunięcie poprzedniego.
\begin{lstlisting}
 >>> python_list = [1, 2, 3, 4]
 >>> before_append = id(python_list)
 >>> python_list.append(5)
 >>> python_list
 [1, 2, 3, 4, 5]
 >>> after_append = id(python_list)
 >>> print(before_append, after_append)
 (140635439293360, 140635439293360)
 >>> print(before_append == after_append)
 True
 >>> 
 >>> 
 >>> import numpy as np
 >>> np_array = np.zeros(shape=(1, 4))
 >>> np_array
 array([[ 0.,  0.,  0.,  0.]])
 >>> before_resize = id(np_array)
 >>> np_array = np.resize(np_array, (1, 5))
 >>> np_array
 array([[ 0.,  0.,  0.,  0.,  0.]])
 >>> after_resize = id(np_array)
 >>> print(before_resize, after_resize)
 (139910114654128, 139910001813664)
 >>> print(before_resize == after_resize)
 False
 >>> 
\end{lstlisting}

Powyższa cecha obiektów biblioteki \textit{NumPy} oznacza, że wykonywanie operacji na takich obiektach powinno być bardziej skuteczne pod względem czasu ich przeprowadzania.
Jednakże wielokrotne przebudowywanie struktury obiektu wiąże się z bardzo dużym zużyciem pamięci, dlatego polecane jest stosowanie konwersji i tworzenie obiektów dopiero w momencie, kiedy dane są skompletowane i gotowe do przetwarzania\cite{numpy_ug}.\\

Biblioteka \textit{SciPy} zbudowana jest na podstawie biblioteki \textit{NumPy} i rozszerza ją o wiele algorytmów analizy danych.
Elementami składowymi tej biblioteki są między innymi\cite{numpy_ug}:
\begin{itemize}
 \item \textbf{cluster} - algorytmy klastrowania
 \item \textbf{linalg} - algebra liniowa
 \item \textbf{signal} - przetwarzanie sygnałów
 \item \textbf{stats} - funkcje i algorytmy statystyczne
\end{itemize}

Funkcjonalność biblioteki jest bardzo szeroka, dzięki czemu znajduje ona zastosowanie w wielu projektach, a także jest ona częścią składową inych bibliotek analitycznych języka Python.
Przykładową metodą należącą do biblioteki \textit{stats} jest \textit{linregress}, która umożliwia przeprowadzenie regresji liniowej dla wskazanych danych.
\begin{lstlisting}
 >>> from scipy import stats
 >>> import numpy as np
 >>>
 >>> data_x = np.random.random_integers(1, 99, 10)
 >>> data_y = np.random.random_integers(1, 99, 10)
 >>> data_x
 array([72, 45, 69, 52, 93, 14, 80, 14, 13,  5])
 >>> data_y
 array([37, 90, 19,  7, 95, 89, 88, 94, 81, 19])
 >>>
 >>> slope, intercept, r_value,
     p_value, std_err = stats.linregress(data_x, data_y)
 >>> print(slope, intercept, r_value, p_value, std_err)
 (-0.033350664784966184, 63.424125380672955,
  -0.029541780200591877, 0.93543372355182242, 0.39896357644710517)
 >>> 
\end{lstlisting}

\section{Pakiet Scikit-learn}

\subsection{Cel i przeznaczenie pakietu}
Biblioteka \textit{Scikit-learn} zawiera zestaw zaawansowanych narzędzi stosujących uczenie maszynowe do analizy danych w języku Python.
Dystrybuowana jest na licencji BSD, która pozwala na modyfikowanie i rozprowadzanie kodu źródłowego, a nawet na włączanie go do produktów komercyjnych pod warunkiem unieszczenia w dokumentacji odpowiednich adnotacji dotyczących autorów.
Dzięki temu zaliczana jest do wolnego oprogramowania, które rozwijane jest przez społeczność kontrybutorów.
Większa część kodu stworzona jest bezpośrednio w języku Python, lecz niektóre elementy takie jak na przykład implementacje SVM oraz modeli liniowych oparte są na bibliotekach języka C++, odpowiednio LibSVM oraz LibLinear\cite{scikit_article}.\\

Podstawowym założeniem twórców biblioteki jest priorytetyzacja utrzymywania jakości i czytelności kodu, ponad implemenację bardzo wielu funkcji\cite{scikit_article}.
Dodatkowo rozwijana jest wysokeij jakości kompleksowa dokumentacja, co razem stanowi bardzą dobrą bazę do rozwijania całego projektu przez wielu niezależnych deweloperów i wydawania stabilnych wersji produktu.
Scikit-learn bazuje na trzech bibliotekach języka Python: \textit{NumPy}, \textit{SciPy} i \textit{Matplotlib}, i stanowią one wymagania systemowe, niezbędne do poprawnego działania pakietu.\\

W pakiecie \textit{Scikit-learn} algorytmy podzielone są na algorytmy uczenia z nadzorem oraz algorytmy uczenia bez nadzoru\cite{scikit_doc}.
Pierwsze z nich operają się o podział danych na uczące i testowe, gdzie dane uczące zawierają przykładowe oczekiwane wartości na podstawie których budowany jest model.
W zestawie algorytmów uczenia nadzorowanego znaleźć można między innymi\cite{scikit_doc}:
\begin{itemize}
 \item Ogólne modele liniowe
 \item Liniową i kwadratową analizę dyskryminacyjną
 \item Regresję grzbietową (KRR)
 \item Maszynę wektorów nośnych (SVM)
 \item Algorytm k najbliższych sąsiadów
 \item Proces Gaussa
 \item Naiwny klasyfikator Bayesa
 \item Drzewa decyzyjne
\end{itemize}

Algorytmy uczenia bez nadzoru w pakiecie \textit{Scikit-learn}, dla których dane uczące nie posiadają żadnych wartości odniesienia, możemy natomiast podzielić między innymi na:
\begin{itemize}
 \item Klasteryzację
 \item Estymację kowariancji
 \item Nieliniową redukcję przestrzenną
\end{itemize}
\\
W niniejszej pracy zastoswane zostały algorytmy uczenia z nadzorem, należące do grup: \textit{Ogólne modele liniowe}, \textcolor{red}{Uzupełnić!}

\subsection{Ogólne modele liniowe}
W pakiecie \textit{Scikit-learn} przedstawione zostały algorytmy regresji, w których oczekiwane wartości docelowe są liniową kombinacją wartości wejściowych.
Podstawę stanowi równanie regresji:
\begin{ceqn}
\begin{align}
\hat{y} = \omega_{0} + \omega_{1}X_{1} + \omega_{2}X_{2} + ... + \omega_{p}X_{k}
\end{align}
\end{ceqn}

Wektor $\omega = (\omega_{1}, ..., \omega_{p})$ jest utożsamiany z parametrem \textit{coef\_}, a wyraz wolny $\omega_{0}$ z parametrem \textit{intercept\_} \cite{scikit_doc}.

\subsubsection{Regresja liniowa}
Regresja liniowa w pakiecie \textit{Sciki-learn} reprezentowana jest przez obiekt \textbf{LinearRegression}.



\subsection{Wybrane modele klasyfikacji i regresji}
